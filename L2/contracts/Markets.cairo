%lang starknet

%builtins pedersen range_check ecdsa

from starkware.cairo.common.cairo_builtins import HashBuiltin
from starkware.cairo.common.math import assert_not_zero
from starkware.starknet.common.syscalls import get_caller_address

# @notice Stores the address of AdminAuth contract
@storage_var
func auth_address() -> (contract_address : felt):
end

# @notice Stores the address of Asset contract
@storage_var
func asset_contract_address() -> (res : felt):
end

# @notice struct to store details of markets
struct Market:
    member asset: felt
    member asset_collateral: felt
    member leverage: felt
    member tradable: felt
end

# @notice struct to store details of assets
struct Asset:
    member asset_version: felt
    member ticker: felt
    member short_name: felt
    member tradable: felt
    member collateral: felt
    member token_decimal: felt
    member metadata_id: felt
    member tick_size: felt
    member step_size: felt
    member minimum_order_size: felt
    member minimum_leverage: felt
    member maximum_leverage: felt
    member currently_allowed_leverage: felt
    member maintenance_margin_fraction: felt
    member initial_margin_fraction: felt
    member incremental_initial_margin_fraction: felt
    member incremental_position_size: felt
    member baseline_position_size: felt
    member maximum_position_size: felt
end

# @notice Mapping between market ID and Market data
@storage_var
func market(id: felt) -> (res : Market):
end

# @notice Constructor of the smart-contract
# @param _authAddress Address of the adminAuth contract
# @param _asset_contract Address of the Asset contract
@constructor
func constructor{
    syscall_ptr : felt*, 
    pedersen_ptr : HashBuiltin*, 
    range_check_ptr
}(
    _authAddress : felt, 
    _asset_contract : felt
):
    auth_address.write(value = _authAddress)
    asset_contract_address.write(value = _asset_contract)
    return ()
end

# @notice Add market function
# @param id - random string generated by zkxnode's mongodb
# @param newMarket - Market struct variable with the required details
# if tradable value of newMarket = 2, it means take value from Asset contract
@external
func addMarket{
    syscall_ptr : felt*, 
    pedersen_ptr : HashBuiltin*,
    range_check_ptr
}(id: felt, newMarket: Market) :
    alloc_locals
    # Auth Check
    let (caller) = get_caller_address()
    let (auth_addr) = auth_address.read()
    let (access) = IAdminAuth.get_admin_mapping(contract_address = auth_addr, address = caller, action = 0)
    assert_not_zero(access)

    # Getting asset details
    let (asset_address) = asset_contract_address.read()
    let (asset1 : Asset) = IAsset.getAsset(contract_address = asset_address, id = newMarket.asset)
    let (asset2 : Asset) = IAsset.getAsset(contract_address = asset_address, id = newMarket.asset_collateral)

    assert_not_zero(asset2.collateral)
    assert_not_zero(asset1.ticker)

    if newMarket.tradable == 2:
        market.write(id = id, value = Market(asset = newMarket.asset, asset_collateral = newMarket.asset_collateral, leverage = newMarket.leverage, tradable = asset1.tradable))
    else:
        if newMarket.tradable == 1:
            assert_not_zero(asset1.tradable)
        end
        market.write(id = id, value = newMarket)
    end

    return ()
end

# @notice Remove market function
# @param id - random string generated by zkxnode's mongodb
@external
func removeMarket{
    syscall_ptr : felt*,
    pedersen_ptr : HashBuiltin*,
    range_check_ptr
}(id: felt) :
    alloc_locals
    # Auth Check
    let (caller) = get_caller_address()
    let (auth_addr) = auth_address.read()

    let (access) = IAdminAuth.get_admin_mapping(contract_address = auth_addr, address = caller, action = 0)
    assert_not_zero(access)

    market.write(id = id, value = Market(asset = 0, asset_collateral = 0, leverage = 0, tradable = 0))
    return ()
end

# @notice Modify leverage for market
# @param id - random string generated by zkxnode's mongodb
# @param leverage - new value for leverage
@external
func modifyLeverage{
    syscall_ptr : felt*,
    pedersen_ptr : HashBuiltin*,
    range_check_ptr
}(id: felt, leverage: felt) :
    alloc_locals
    # Auth Check
    let (caller) = get_caller_address()
    let (auth_addr) = auth_address.read()

    let (access) = IAdminAuth.get_admin_mapping(contract_address = auth_addr, address = caller, action = 0)
    assert_not_zero(access)

    let (_market : Market) = market.read(id = id)

    market.write(id = id, value = Market(asset = _market.asset, asset_collateral = _market.asset_collateral, leverage = leverage, tradable = _market.tradable))
    return ()
end

# @notice Modify tradable flag for market
# @param id - random string generated by zkxnode's mongodb
# @param leverage - new value for tradable flag
@external
func modifyTradable{
    syscall_ptr : felt*,
    pedersen_ptr : HashBuiltin*,
    range_check_ptr
}(id: felt, tradable: felt) :
    alloc_locals
    # Auth Check
    let (caller) = get_caller_address()
    let (auth_addr) = auth_address.read()

    let (access) = IAdminAuth.get_admin_mapping(contract_address = auth_addr, address = caller, action = 0)
    assert_not_zero(access)

    let (_market : Market) = market.read(id = id)

    let (asset_address) = asset_contract_address.read()
    let (asset1 : Asset) = IAsset.getAsset(contract_address = asset_address, id = _market.asset)

    if _market.tradable == 2:
        market.write(id = id, value = Market(asset = _market.asset, asset_collateral = _market.asset_collateral, leverage = _market.leverage, tradable = asset1.tradable))
    else:
        if tradable == 1:
            assert_not_zero(asset1.tradable)
        end
        market.write(id = id, value = Market(asset = _market.asset, asset_collateral = _market.asset_collateral, leverage = _market.leverage, tradable = tradable))
    end

    return ()
end

# @notice Getter function for Markets
# @param id - random string generated by zkxnode's mongodb
# @returns currMarket - Returns the requested market
@view
func getMarket{
    syscall_ptr : felt*, 
    pedersen_ptr : HashBuiltin*,
    range_check_ptr
}(id: felt) -> (currMarket: Market) :

    let (currMarket) = market.read(id = id)
    return (currMarket)
end

# @notice AdminAuth interface
@contract_interface
namespace IAdminAuth:
    func get_admin_mapping(address : felt, action : felt) -> (allowed : felt):
    end
end

# @notice Asset interface
@contract_interface
namespace IAsset:
    func getAsset(id: felt) -> (
        currAsset: Asset
    ):
    end
end