%lang starknet
%builtins pedersen range_check ecdsa

from starkware.cairo.common.alloc import alloc
from starkware.starknet.common.messages import send_message_to_l1
from starkware.cairo.common.cairo_builtins import HashBuiltin
from starkware.cairo.common.math import assert_not_zero
from starkware.starknet.common.syscalls import get_caller_address

const ADD_ASSET = 1

#
# Structs
#

# @notice struct to store details of assets
struct Asset:
    member ticker: felt
    member short_name: felt
    member tradable: felt
    member collateral: felt
end

#
# Storage
#

# @notice Stores the address of AdminAuth contract
@storage_var
func auth_address() -> (contract_address : felt):
end

# @notice stores the address of L1 zkx contract
@storage_var
func L1_zkx_address() -> (res : felt):
end

# @notice Mapping between asset ID and Asset data
@storage_var
func asset(id: felt) -> (res : Asset):
end


#
# Setters
#

# @notice set L1 zkx contract address function
# @param address - L1 zkx contract address as an argument
@external
func set_L1_zkx_address{
    syscall_ptr : felt*, 
    pedersen_ptr : HashBuiltin*, 
    range_check_ptr
}(l1_zkx_address : felt):
    alloc_locals
    # Auth Check
    let (caller) = get_caller_address()
    let (auth_addr) = auth_address.read()

    let (access) = IAdminAuth.get_admin_mapping(contract_address = auth_addr, address = caller, action = 1)
    assert_not_zero(access)

    L1_zkx_address.write(value = l1_zkx_address)
    return ()
end

#
# Getters
#

# @notice get L1 zkx contract address function
@view
func get_L1_zkx_address{
    syscall_ptr : felt*, 
    pedersen_ptr : HashBuiltin*, 
    range_check_ptr
}() -> (res : felt):
    let (res) = L1_zkx_address.read()
    return (res=res)
end

# @notice Getter function for Assets
# @param id - random string generated by zkxnode's mongodb
# @returns currAsset - Returns the requested asset
@view
func getAsset{
    syscall_ptr : felt*, 
    pedersen_ptr : HashBuiltin*,
    range_check_ptr
}(id: felt) -> (currAsset: Asset) :

    let (currAsset) = asset.read(id = id)
    return (currAsset)
end


#
# Constructor
#

# @notice Constructor of the smart-contract
# @param _authAddress Address of the adminAuth contract
@constructor
func constructor{
    syscall_ptr : felt*, 
    pedersen_ptr : HashBuiltin*, 
    range_check_ptr
}(_authAddress : felt):

    auth_address.write(value = _authAddress)
    return ()
end

#
# Business logic
#

# @notice Add asset function
# @param id - random string generated by zkxnode's mongodb
# @param Asset - Asset struct variable with the required details
@external
func addAsset{
    syscall_ptr : felt*, 
    pedersen_ptr : HashBuiltin*,
    range_check_ptr
}(id: felt, newAsset: Asset) :
    alloc_locals
    # Auth Check
    let (caller) = get_caller_address()
    let (auth_addr) = auth_address.read()
    let (access) = IAdminAuth.get_admin_mapping(contract_address = auth_addr, address = caller, action = 1)
    assert_not_zero(access)

    asset.write(id = id, value = newAsset)
    return ()
end

# @notice Remove asset function
# @param id - random string generated by zkxnode's mongodb
@external
func removeAsset{
    syscall_ptr : felt*,
    pedersen_ptr : HashBuiltin*,
    range_check_ptr
}(id: felt) :
    alloc_locals
    # Auth Check
    let (caller) = get_caller_address()
    let (auth_addr) = auth_address.read()

    let (access) = IAdminAuth.get_admin_mapping(contract_address = auth_addr, address = caller, action = 1)
    assert_not_zero(access)

    asset.write(id = id, value = Asset(ticker = 0, short_name = 0, tradable = 0, collateral = 0))
    return ()
end

# @notice Modify asset function
# @param id - random string generated by zkxnode's mongodb
# @param editedAsset - Asset struct variable with the modified details
@external
func modifyAsset{
    syscall_ptr : felt*,
    pedersen_ptr : HashBuiltin*,
    range_check_ptr
}(id: felt, editedAsset: Asset) :
    alloc_locals
    # Auth Check
    let (caller) = get_caller_address()
    let (auth_addr) = auth_address.read()

    let (access) = IAdminAuth.get_admin_mapping(contract_address = auth_addr, address = caller, action = 1)
    assert_not_zero(access)

    asset.write(id = id, value = editedAsset)
    return ()
end

# @notice Function to update asset list in L1
# @param amount - The Amount of funds that user wants to withdraw
@external
func updateAssetListInL1{
    syscall_ptr : felt*, 
    pedersen_ptr : HashBuiltin*, 
    range_check_ptr
}(assetId : felt, ticker : felt):
    alloc_locals
    # Auth Check
    let (caller) = get_caller_address()
    let (auth_addr) = auth_address.read()

    let (access) = IAdminAuth.get_admin_mapping(contract_address = auth_addr, address = caller, action = 1)
    assert_not_zero(access)

    # Send the add asset message.
    let (message_payload : felt*) = alloc()
    assert message_payload[0] = ADD_ASSET
    assert message_payload[1] = ticker
    assert message_payload[2] = assetId

    let (L1_CONTRACT_ADDRESS) = get_L1_zkx_address()

    send_message_to_l1(to_address=L1_CONTRACT_ADDRESS, payload_size=3, payload=message_payload)

    return ()
end

# @notice AdminAuth interface
@contract_interface
namespace IAdminAuth:
    func get_admin_mapping(address : felt, action : felt) -> (allowed : felt):
    end
end